be/src/vec/runtime/vdata_stream_mgr.cpp (line 148) – The change reverts the earlier fix that copied each incoming PBlock before handing it to the receiver. The old comment right above the code explains that using const_cast/Swap on request->blocks(i) had previously caused “hard‑to‑reproduce core dumps”, so the code was intentionally changed to copy instead. This PR brings back pblock_ptr->Swap(const_cast<PBlock*>(&request->blocks(i))) (and the same pattern for request->block()), which again mutates the protobuf owned by brpc and risks the exact crash we already hit. The request object is supposed to stay immutable while brpc still owns it; swapping it out reintroduces the race/UB the original fix avoided.

be/src/util/slice.h (line 93) – Slice::mutable_data() was turned into a const method returning the raw char*. A Slice very often wraps string literals or other read‑only buffers (the constructors happily accept const char* and simply store the pointer via const_cast). Making mutable_data() callable on a const Slice now allows code to mutate those read‑only buffers without any compiler diagnostics. Previously you had to drop constness explicitly, which at least highlighted the danger. With the new signature even a const Slice built from a literal – e.g. const Slice key("abc",3); key.mutable_data()[0]='x'; – now compiles but writes into read‑only storage, producing UB/crashes. This widens the surface for subtle memory‑corruption bugs (see the new Slice usage in vec/functions/function_jsonb.cpp (line 2382), which now happily obtains a writeable pointer from a JSON Key slice).
